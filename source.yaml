- ID: 0
  Plain: >-
    In a system-on-chip (SoC), software will commonly access the peripherals through a memory-mapped register 
    interface. Thus, software can access only certain registers with respect to their privilege level hardcoded 
    in the design. However, through the accessible register interface, malicious software could tamper the 
    hardware data. This threat could allow any adversary to exploit a weakness enabling them to elevate their 
    privilege and perform an action that they are not supposed to be authorized to perform. 
  Threat: "Software"
  CWE: 1198
  CAPEC: 233
  Assertions: |-
    property one1;
      @(posedge clk_i) (debug_req_i == 1’b0)|-> (ariane.csr_regfile_i.priv_lvl_o == riscv::PRIV_LVL_S) or (ariane.csr_regfile_i.priv_lvl_o == riscv::PRIV_LVL_U) or (ariane.csr_regfile_i.priv_lvl_o == riscv::PRIV_LVL_M);
    endproperty
    property one2;
      @(posedge clk_i) (debug_req_i == 1’b1)|-> (ariane.csr_regfile_i.priv_lvl_o == riscv::PRIV_LVL_M); //machine mode is low-priviledged
    endproperty
    property one3;
      @(posedge clk_i) (debug_req_i == 1’b1)|-> (ariane.csr_regfile_i.priv_lvl_o != riscv::PRIV_LVL_U);
    endproperty
    property one4;
      @(posedge clk_i) (debug_req_i == 1’b1)|-> (ariane.csr_regfile_i.priv_lvl_o != riscv::PRIV_LVL_S);
    endproperty
    ap_vulnerability11: assert property (one1);
    ap_vulnerability12: assert property (one2);
    ap_vulnerability13: assert property (one3);
    ap_vulnerability14: assert property (one4);
  Design: "Ariane"
  Origin: "CAD for Security"
  Reference: "http://cad4security.org/index.php/riscv-vulnerability-details/soc-vulnerability-1"

- ID: 1
  Plain: >-
    In a system-on-chip (SoC), software will commonly access the peripherals through a memory-mapped register 
    interface. Thus, software can access only certain registers with respect to their privilege level hardcoded 
    in the design. However, through the accessible register interface, malicious software could tamper the 
    hardware data. This threat could allow any adversary to exploit a weakness enabling them to elevate their 
    privilege and perform an action that they are not supposed to be authorized to perform. 
  Threat: "Software"
  CWE: 266
  CAPEC: 233
  Assertions: |-
    property one1;
      @(posedge clk_i) (debug_req_i == 1’b0)|-> (ariane.csr_regfile_i.priv_lvl_o == riscv::PRIV_LVL_S) or (ariane.csr_regfile_i.priv_lvl_o == riscv::PRIV_LVL_U) or (ariane.csr_regfile_i.priv_lvl_o == riscv::PRIV_LVL_M);
    endproperty
    property one2;
      @(posedge clk_i) (debug_req_i == 1’b1)|-> (ariane.csr_regfile_i.priv_lvl_o == riscv::PRIV_LVL_M); //machine mode is low-priviledged
    endproperty
    property one3;
      @(posedge clk_i) (debug_req_i == 1’b1)|-> (ariane.csr_regfile_i.priv_lvl_o != riscv::PRIV_LVL_U);
    endproperty
    property one4;
      @(posedge clk_i) (debug_req_i == 1’b1)|-> (ariane.csr_regfile_i.priv_lvl_o != riscv::PRIV_LVL_S);
    endproperty
    ap_vulnerability11: assert property (one1);
    ap_vulnerability12: assert property (one2);
    ap_vulnerability13: assert property (one3);
    ap_vulnerability14: assert property (one4);
  Design: "Ariane"
  Origin: "CAD for Security"
  Reference: "http://cad4security.org/index.php/riscv-vulnerability-details/soc-vulnerability-2"

- ID: 2
  Plain: >-
    In a system-on-chip (SoC), software will commonly access the peripherals through a memory-mapped register 
    interface. Thus, software can access only certain registers with respect to their privilege level hardcoded 
    in the design. However, through the accessible register interface, malicious software could tamper the 
    hardware data. This threat could allow any adversary to exploit a weakness enabling them to elevate their 
    privilege and perform an action that they are not supposed to be authorized to perform. 
  Threat: "Software"
  CWE: 1198
  CAPEC: 233
  Assertions: |-
    property one1;
      @(posedge clk_i) (debug_req_i == 1’b0)|-> (ariane.csr_regfile_i.priv_lvl_o == riscv::PRIV_LVL_S) or (ariane.csr_regfile_i.priv_lvl_o == riscv::PRIV_LVL_U) or (ariane.csr_regfile_i.priv_lvl_o == riscv::PRIV_LVL_M);
    endproperty
    property one2;
      @(posedge clk_i) (debug_req_i == 1’b1)|-> (ariane.csr_regfile_i.priv_lvl_o == riscv::PRIV_LVL_M); //machine mode is low-priviledged
    endproperty
    property one3;
      @(posedge clk_i) (debug_req_i == 1’b1)|-> (ariane.csr_regfile_i.priv_lvl_o != riscv::PRIV_LVL_U);
    endproperty
    property one4;
      @(posedge clk_i) (debug_req_i == 1’b1)|-> (ariane.csr_regfile_i.priv_lvl_o != riscv::PRIV_LVL_S);
    endproperty
    ap_vulnerability11: assert property (one1);
    ap_vulnerability12: assert property (one2);
    ap_vulnerability13: assert property (one3);
    ap_vulnerability14: assert property (one4);
  Design: "Ariane"
  Origin: "CAD for Security"
  Reference: "http://cad4security.org/index.php/riscv-vulnerability-details/soc-vulnerability-3"

- ID: 3
  Plain: >-
    In a system-on-chip (SoC), the software will commonly access the peripherals through a memory-mapped register 
    interface. Thus, the software can access only certain registers with respect to their privilege level 
    hardcoded in the design. However, through the accessible register interface, malicious software could tamper 
    with the hardware data. During the execution of an instruction, the privilege level should not be altered. 
    Changing the privilege level during this can lead to access control violations and possible integrity loss. 
  Threat: "Software"
  CWE: 1272
  CAPEC: 233
  Assertions: |-
    property priv_viol;  
      @(posedge clk_i)  disable iff (!rst_ni)  ( ariane.csr_regfile_i.privilege_violation) |-> (~ariane.csr_regfile_i.csr_we  && ~ariane.csr_regfile_i.csr_read );
  Design: "Ariane"
  Origin: "CAD for Security"
  Reference: "http://cad4security.org/index.php/riscv-vulnerability-details/soc-vulnerability-4"

- ID: 4
  Plain: >-
    In a system-on-chip (SoC), the software will commonly access the peripherals through a memory-mapped register 
    interface. Thus, the software can access only certain registers with respect to their privilege level 
    hardcoded in the design. However, through the accessible register interface, malicious software could tamper 
    with the hardware data. The memory management unit (MMU) determines the memory page access permission for 
    different privilege levels. This vulnerability allows any attacker to access supervisor or machine-level 
    memory pages from user-level privilege mode without generating any data access error. 
  Threat: "Software"
  CWE: 1262
  CAPEC: 233
  Assertions: |-
    property mmu;
      @(posedge clk_i) disable iff (!rst_ni) (ariane.ex_stage_i.lsu_i.i_mmu.icache_areq_i.fetch_req && ((ariane.ex_stage_i.lsu_i.i_mmu.priv_lvl_i == riscv::PRIV_LVL_U) && ~ariane.ex_stage_i.lsu_i.i_mmu.itlb_content.u)) |-> (ariane.ex_stage_i.lsu_i.i_mmu.iaccess_err == 1);
    endproperty
    ap_vulnerability123: assert property (mmu);
  Design: "Ariane"
  Origin: "CAD for Security"
  Reference: "http://cad4security.org/index.php/riscv-vulnerability-details/soc-vulnerability-5"

- ID: 5
  Plain: >-
    In a system-on-chip (SoC), the software will commonly access the peripherals through a memory-mapped register 
    interface. Thus, the software can access only certain registers with respect to their privilege level 
    hardcoded in the design. However, through the accessible register interface, malicious software could tamper 
    with the hardware data. The physical memory protection (PMP) unit takes care of the address translation for 
    the physical memory locations inside the processor. If there is any mismatch during this process, no physical 
    memory access is given to the lower privilege levels. However, this vulnerability can enable an attacker to 
    gain the memory access even with lower privilege levels (S mode and U mode). 
  Threat: "Software"
  CWE: 1262
  CAPEC: 233
  Assertions: |-
    property pmp;
      (posedge clk_i) disable iff (!rst_ni) (ariane.ex_stage_i.lsu_i.i_mmu.i_pmp_if.priv_lvl_i == riscv::PRIV_LVL_S) |-> (ariane.ex_stage_i.lsu_i.i_mmu.i_pmp_if.allow_o !=1);
    endproperty
    ap_vulnerability126: assert property (pmp);
  Design: "Ariane"
  Origin: "CAD for Security"
  Reference: "http://cad4security.org/index.php/riscv-vulnerability-details/soc-vulnerability-6"

- ID: 6
  Plain: >-
    Encryption key should not be observable from test and debug ports.
  Threat: ""
  CWE: -1
  CAPEC: -1
  Tool: "JasperGold SPV"
  Assertions: |-
    check_spv -create -from {key} -to {test_so} -name "observability_of_key"
  Design: "Trust-Hub GEM031"
  Origin: "Trust-Hub"
  Reference: "https://trust-hub.org/downloads/resource/data/property-db/GEM031.zip"

- ID: 7
  Plain: >-
    FSM State flip-flop should not be controllable and observable from the additional test and debug ports. 
  Threat: ""
  CWE: -1
  CAPEC: -1
  Tool: "JasperGold SPV"
  Assertions: |-
    check_spv -create -from {test_si} -to {next_FSM} -name "controllability_of_state_flip_flop"
    check_spv -create -from {next_FSM} -to {test_so} -name "observability_of_state_flip_flop"
  Design: "Trust-Hub GEM032"
  Origin: "Trust-Hub"
  Reference: "https://trust-hub.org/downloads/resource/data/property-db/GEM032.zip"

- ID: 8
  Plain: >-
    For a certain FSM state encoding scheme, the Fault Injection Feasibility (FIF) metric should not have the value 1.
  Threat: ""
  CWE: -1
  CAPEC: -1
  Tool: "JasperGold"
  Assertions: |-
    property FI_vulnerability;
      @(posedge clk) (!(aes_binary.FSM==FINAL_ROUND) && !($past(aes_binary.FSM)==FINAL_ROUND)) |-> !((!(aes_binary.FSM[0] ^ FINAL_ROUND[0]) | !($past(aes_binary.FSM[0]) ^ FINAL_ROUND[0]) ) && (!(aes_binary.FSM[1] ^ FINAL_ROUND[1]) | !($past(aes_binary.FSM[1]) ^ FINAL_ROUND[1]) ) && (!(aes_binary.FSM[2] ^ FINAL_ROUND[2]) | !($past(aes_binary.FSM[2]) ^ FINAL_ROUND[2])));
    endproperty
    checkFI_vulnerability: assert property(FI_vulnerability);
  Design: "Trust-Hub GEM051"
  Origin: "Trust-Hub"
  Reference: "https://trust-hub.org/downloads/resource/data/property-db/GEM051.zip"

- ID: 9
  Plain: >-
    To resist fault injection vulnerability, FSM encoding of encryption algorithm should be implemented in such a way that an FSM state cannot be accessed from a don’t care state. 
  Threat: ""
  CWE: -1
  CAPEC: -1
  Tool: "JasperGold"
  Assertions: |-
    property finalRoundAccessFromDontCare;
      @(posedge clk) (aes_binary.FSM==FINAL_ROUND) |->
        $past(aes_binary.FSM==3'b111) |
        $past(aes_binary.FSM==3'b001) |
        $past(aes_binary.FSM==3'b101);
    endproperty
    checkFinalRoundAccessFromDontCare: assert property(finalRoundAccessFromDontCare);
  Design: "Trust-Hub GEM061"
  Origin: "Trust-Hub"
  Reference: "https://trust-hub.org/downloads/resource/data/property-db/GEM061.zip"

- ID: 10
  Plain: >-
    Final_round of AES should only be accessed from the do_round and should not be accessed from any don’t care states.
  Threat: ""
  CWE: -1
  CAPEC: -1
  Tool: "JasperGold"
  Assertions: |-
    property accessToFinalRound;
      @(posedge clk) (aes_binary.FSM==FINAL_ROUND) |->
      $past(aes_binary.FSM==DO_ROUND) ||
      $past(aes_binary.FSM==FINAL_ROUND);
    endproperty
    checkAccessToFinalRound: assert property(accessToFinalRound);
  Design: "Trust-Hub GEM062"
  Origin: "Trust-Hub"
  Reference: "https://trust-hub.org/downloads/resource/data/property-db/GEM062.zip"

- ID: 11
  Plain: >-
    RESULT state should only be accessed from SQR state and should not be accessed from any don’t care states. 
  Threat: ""
  CWE: -1
  CAPEC: -1
  Tool: "JasperGold"
  Assertions: |-
    property dontCareState;
      @(posedge clk) (RSA_binary.FSM==RESULT) |->
      $past(RSA_binary.FSM==RESULT) ||
      $past(RSA_binary.FSM==SQR);
    endproperty
    checkAccessFromDontCareState: assert property(dontCareState);
  Design: "Trust-Hub GEM063"
  Origin: "Trust-Hub"
  Reference: "https://trust-hub.org/downloads/resource/data/property-db/GEM063.zip"

- ID: 12
  Plain: >-
    A reset signal should be enabled for the scan flip-flops whenever there is a switch from the functional mode to the test mode.
  Threat: ""
  CWE: -1
  CAPEC: -1
  Tool: "JasperGold"
  Assertions: |-
    property testmode;
      @(posedge clk) (RSA_binary.test_se==1) ##1 (RSA_binary.test_se==0)| -> (RSA_binary.RESET==1);
    endproperty
    checktestmode: assert property(testmode);
  Design: "Trust-Hub GTD022"
  Origin: "Trust-Hub"
  Reference: "https://trust-hub.org/downloads/resource/data/property-db/GTD022.zip"

- ID: 13
  Plain: >-
    Timing violation, computational, or execution fault can result in erroneous state transition of FSM, which can be exploited to perform 
    fault injection attack. When state transition takes place between two consecutive unprotected states, then hamming distance between 
    the encoded states should be 1.
  Threat: ""
  CWE: -1
  CAPEC: -1
  Tool: "JasperGold"
  Assertions: |-
    property one;
      @(posedge i_clk) $countones (door_lock_FSM.INITIAL_SET ^ door_lock_FSM.VERIFY) == 1;
    endproperty
    property two;
      @(posedge i_clk) $countones (door_lock_FSM.VERIFY ^ door_lock_FSM.VERIFY_SUCCESS) == 1;
    endproperty
    property three;
      @(posedge i_clk) $countones (door_lock_FSM.VERIFY ^ door_lock_FSM.VERIFY_FAIL) == 1;
    endproperty
    property four;
      @(posedge i_clk) $countones (door_lock_FSM.VERIFY ^ door_lock_FSM.SET) == 1;
    endproperty
    property five;
      @(posedge i_clk) $countones (door_lock_FSM.VERIFY_SUCCESS ^ door_lock_FSM.SET) == 1;
    endproperty
    property six;
      @(posedge i_clk) $countones (door_lock_FSM.VERIFY_FAIL ^ door_lock_FSM.SET) == 1;
    endproperty
    ap_door_lock_vulnerability1: assert property (one)
    ap_door_lock_vulnerability2: assert property (two)
    ap_door_lock_vulnerability3: assert property (three)
    ap_door_lock_vulnerability4: assert property (four)
    ap_door_lock_vulnerability5: assert property (five)
    ap_door_lock_vulnerability6: assert property (six)
  Design: "Trust-Hub RCD011"
  Origin: "Trust-Hub"
  Reference: "https://trust-hub.org/downloads/resource/data/property-db/RCD011.zip"

- ID: 14
  Plain: >-
    All unused states of an FSM should be handled through default statement which ensures the system to be in secure state.
  Threat: ""
  CWE: -1
  CAPEC: -1
  Tool: "JasperGold"
  Assertions: |-
    property unused_state_vulnerability1;
      @(posedge clk) disable iff (rst_n) (user_input == 3'b111) || (user_input == 3'b110) |=> (fsm_1.state == 2'h01);
    endproperty
    ap_unused_state_vulnerability1: assert property (unused_state_vulnerability1)
  Design: "Trust-Hub RCD012"
  Origin: "Trust-Hub"
  Reference: "https://trust-hub.org/downloads/resource/data/property-db/RCD012.zip"

- ID: 15
  Plain: >-
    Control and status register’s contents should be copied to/from any general-purpose registers based on the access 
    type (read-only, write-only, read-write etc.) of each bit of the control and status register.
  Threat: ""
  CWE: -1
  CAPEC: -1
  Tool: "JasperGold CSR"
  Assertions: |-
    Access description for JasperGold CSR
  Design: "Trust-Hub RCD021"
  Origin: "Trust-Hub"
  Reference: "https://trust-hub.org/downloads/resource/data/property-db/RCD021.zip"

- ID: 16
  Plain: >-
    Privilege level of the load and store module should not be changed if the previous privilege level of the host 
    processor was set higher than current privilege level.
  Threat: ""
  CWE: -1
  CAPEC: -1
  Tool: "JasperGold"
  Assertions: |-
    property vul_PMU_priv_level_1;
      @(posedge clk_i) csr_regfile_i.mprv == 1 |-> csr_regfile_i.ld_st_priv_lvl_o == csr_regfile_i.mstatus_q.mpp;
    endproperty
    property vul_PMU_priv_level_2;
      @(posedge clk_i) csr_regfile_i.mprv == 0 |-> csr_regfile_i.ld_st_priv_lvl_o == csr_regfile_i.priv_lvl_o;
    endproperty
    ap_vul_PMU_priv_level_1: assert property (vul_PMU_priv_level_1);
    ap_vul_PMU_priv_level_2: assert property (vul_PMU_priv_level_2);
  Design: "Trust-Hub RCD032"
  Origin: "Trust-Hub"
  Reference: "https://trust-hub.org/downloads/resource/data/property-db/RCD032.zip"

- ID: 17
  Plain: >-
    Load-Store Unit (LSU) should not accept access requests if more outstanding transactions are requested than its 
    depth. (The depth of an LSU is the capability of handling the number of transactions that are in queue to be executed). 
  Threat: ""
  CWE: -1
  CAPEC: -1
  Tool: "JasperGold"
  Assertions: |-
    property p_no_transaction_count_overflow_0;
      @(posedge clk_i) disable iff (!rst_ni) (1'b1) |-> (load_store_unit_i.cnt_q <= load_store_unit_i.DEPTH);
    endproperty
    property p_no_transaction_count_overflow_1;
      @(posedge clk_i) disable iff (!rst_ni) (load_store_unit_i.data_req_ex_i && load_store_unit_i.cnt_q > load_store_unit_i.DEPTH) |-> (load_store_unit_i.trans_valid == 1'b1);
    endproperty
    a_no_transaction_count_overflow_0: assert property(p_no_transaction_count_overflow_0);
    a_no_transaction_count_overflow_1: cover property(p_no_transaction_count_overflow_1);
  Design: "Trust-Hub RCD041"
  Origin: "Trust-Hub"
  Reference: "https://trust-hub.org/downloads/resource/data/property-db/RCD041.zip"

- ID: 18
  Plain: >-
    The cipher text ready signal should be low when encryption key is loaded to an AES. 
  Threat: ""
  CWE: -1
  CAPEC: -1
  Tool: "JasperGold"
  Assertions: |-
    property reset_key_load1_done0;
    @(posedge clk)
      disable iff (rst) (ld == 1'b1) |-> (done == 1'b0);
    endproperty
    property reset_key_load1_done;
      if ((rst == 1'b0) && (ld == 1'b1 ) && (done == 1'b1)) key != text_out;
    endproperty
    ap_reset_LD1_D0: assert property (reset_key_load1_done0);
    ap_reset_LD1_DN: assert property (reset_key_load1_done);
  Design: "Trust-Hub REM011"
  Origin: "Trust-Hub"
  Reference: "https://trust-hub.org/downloads/resource/data/property-db/REM011.zip"

- ID: 19
  Plain: >-
    AES key should not be shared with other modules. 
  Threat: ""
  CWE: -1
  CAPEC: -1
  Tool: "JasperGold"
  Assertions: |-
    property AES_key_sharing;
      @(posedge clk) disable iff (rst) (v_top.AES.key != v_top.TSC.key);
    endproperty
    ap_AES_key_sharing: assert property (AES_key_sharing);
  Design: "Trust-Hub REM012"
  Origin: "Trust-Hub"
  Reference: "https://trust-hub.org/downloads/resource/data/property-db/REM012.zip"

- ID: 20
  Plain: >-
    Control registers should not be observable from the output signals. 
  Threat: ""
  CWE: -1
  CAPEC: -1
  Tool: "JasperGold SPV"
  Assertions: |-
    check_spv -create -from next_FSM -to_all {data_stable key_ready finished round_type_sel}
  Design: "Trust-Hub REM013"
  Origin: "Trust-Hub"
  Reference: "https://trust-hub.org/downloads/resource/data/property-db/REM013.zip"

- ID: 21
  Plain: >-
    The cipher-text ready signal should be only asserted from the final round state. 
  Threat: ""
  CWE: -1
  CAPEC: -1
  Tool: "JasperGold"
  Assertions: |-
    property finished signal;
      @(posedge clk) (finished==1'b1) |-> aes_binary.FSM==aes_binary.FINAL_ROUND;
    endproperty
    checkFinishedSignal: assert property(finishedSignal);
  Design: "Trust-Hub REM021"
  Origin: "Trust-Hub"
  Reference: "https://trust-hub.org/downloads/resource/data/property-db/REM021.zip"

- ID: 22
  Plain: >-
    ‘Ready’ signal should be asserted after certain cycles of the INITIAL_ROUND.
  Threat: ""
  CWE: -1
  CAPEC: -1
  Tool: "JasperGold"
  Assertions: |-
    property constantCycleOperation;
      @(posedge clk) $rose(finished) |-> $past(aes_binary.FSM==INITIAL_ROUND, 10);
    endproperty
    checkConstCycle: assert property(constantCycleOperation);
  Design: "Trust-Hub REM022"
  Origin: "Trust-Hub"
  Reference: "https://trust-hub.org/downloads/resource/data/property-db/REM022.zip"

- ID: 23
  Plain: >-
    DO_ROUND must occur before the FINAL_ROUND. 
  Threat: ""
  CWE: -1
  CAPEC: -1
  Tool: "JasperGold"
  Assertions: |-
    property doRoundBeforeFinalRound;
      @(posedge clk) ((aes_binary.FSM==WAIT_DATA) ##1(aes_binary.FSM==INITIAL_ROUND)) ##1 (!((aes_binary.FSM==DO_ROUND) & !(aes_binary.FSM==FINAL_ROUND)))[*1:$] |-> !(aes_binary.FSM==FINAL_ROUND);
    endproperty
    checkDoRoundBeforeFinalRound: assert property(doRoundBeforeFinalRound);
  Design: "Trust-Hub REM023"
  Origin: "Trust-Hub"
  Reference: "https://trust-hub.org/downloads/resource/data/property-db/REM023.zip"

- ID: 24
  Plain: >-
    FINAL_ROUND should only be accessed from DO_ROUND. 
  Threat: ""
  CWE: -1
  CAPEC: -1
  Tool: "JasperGold"
  Assertions: |-
    property accessToFinalRound;
      @(posedge clk) (aes_binary.FSM==FINAL_ROUND) |-> $past(aes_binary.FSM==DO_ROUND) || $past(aes_binary.FSM==FINAL_ROUND);
    endproperty
    checkAccessToFinalRound: assert property(accessToFinalRound);
  Design: "Trust-Hub REM024"
  Origin: "Trust-Hub"
  Reference: "https://trust-hub.org/downloads/resource/data/property-db/REM024.zip"

- ID: 25
  Plain: >-
    AES Key should not flow to the ciphertext when the plain text matches with a specific value. 
  Threat: ""
  CWE: -1
  CAPEC: -1
  Tool: "JasperGold SPV"
  Assertions: |-
    check_spv -create -from {aes.slv_reg7} -to {aes.AES_pipe.cipher_text} -name "key_to_ciphertext"
    check_spv -create -from {aes.slv_reg7} -to {aes.AES_pipe.cipher_text} -from_precond {aes.plain_text[7:0] == 8'hAC || aes.plain_text[15:0] == 16'h1256} -name "key_to_ciphertext_with_precond"
  Design: "Trust-Hub REM025"
  Origin: "Trust-Hub"
  Reference: "https://trust-hub.org/downloads/resource/data/property-db/REM025.zip"

- ID: 26
  Plain: >-
    To avoid side-channel attacks, intermediate variables should not be relevant with a portion (# = k) of key bits (e.g., 1 < k ≤ 32) and plaintext bits (# = m, m > 0)
  Threat: ""
  CWE: -1
  CAPEC: -1
  Tool: "JasperGold SPV"
  Assertions: |-
    assume {clk_count == 0 |-> Drdy == 0}
    assume {clk_count == 1 |-> Drdy == 1}
    assume {clk_count>1 |-> Drdy == 0}
    assume {clk_count == 0 |-> Krdy == 1}
    assume {clk_count == 1 |-> Krdy == 0}
    assume {clk_count>1 |-> Krdy == 0}
    assume {clk_count > 0 |-> EN == 1}
    check_spv -create -from {Krg[32]}   -to {Drg[0]} -to_precond {clk_count == 3}
    # For i in range [0, 127]
    check_spv -create -from {Krg[i]} -to {Drg[0]} -to_precond {clk_count == 3} 
    check_spv -create -from {Din[i]} -to {Drg[0]} -to_precond {clk_count == 3}
  Design: "Trust-Hub REM028"
  Origin: "Trust-Hub"
  Reference: "https://trust-hub.org/downloads/resource/data/property-db/REM028.zip"

- ID: 27
  Plain: >-
    `Finished` signal should be high at `RESULT` state.
  Threat: ""
  CWE: -1
  CAPEC: -1
  Tool: "JasperGold"
  Assertions: |-
    property finishedSignal;
      @(posedge clk) (finished==1'b1) |-> (RSA_binary.FSM==RESULT);
    endproperty
    finishedSignalProperty: assert property(finishedSignal);
  Design: "Trust-Hub REM031"
  Origin: "Trust-Hub"
  Reference: "https://trust-hub.org/downloads/resource/data/property-db/REM031.zip"

- ID: 28
  Plain: >-
    Control registers should not be observable from output signal.
  Threat: ""
  CWE: -1
  CAPEC: -1
  Tool: "JasperGold SPV"
  Assertions: |-
    check_spv -create -from next_FSM -to_all {start finished}
  Design: "Trust-Hub REM032"
  Origin: "Trust-Hub"
  Reference: "https://trust-hub.org/downloads/resource/data/property-db/REM032.zip"

- ID: 29
  Plain: >-
    `RESULT` state can only be accessed from `SQR` state. 
  Threat: ""
  CWE: -1
  CAPEC: -1
  Tool: "JasperGold"
  Assertions: |-
    property accessToResult;
      @(posedge clk) (RSA_binary.FSM==RESULT) |-> $past(RSA_binary.FSM==RESULT) || $past(RSA_binary.FSM==SQR);
    endproperty
    authorizedAccessToResult: assert property(accessToResult);
  Design: "Trust-Hub REM041"
  Origin: "Trust-Hub"
  Reference: "https://trust-hub.org/downloads/resource/data/property-db/REM041.zip"

- ID: 30
  Plain: >-
    `MULT` and `SQR` both states must occur before reaching the `RESULT` state. 
  Threat: ""
  CWE: -1
  CAPEC: -1
  Tool: "JasperGold"
  Assertions: |-
    property multSqrThenResult;
      @(posedge clk) (RSA_binary.FSM==RESULT) |-> $past(RSA_binary.FSM==SQR,1) && $past(RSA_binary.FSM==MULT,2);
    endproperty
    checkMultSqrThenResult: assert property(multSqrThenResult);
  Design: "Trust-Hub REM042"
  Origin: "Trust-Hub"
  Reference: "https://trust-hub.org/downloads/resource/data/property-db/REM042.zip"

- ID: 31
  Plain: >-
    `finished/ready` signal should be high after certain clock cycles of the initial state.
  Threat: ""
  CWE: -1
  CAPEC: -1
  Tool: "JasperGold"
  Assertions: |-
    property constant_9_Cycle;
      @(posedge clk) (finished==1'b1) |-> $past(RSA_binary.FSM==INIT,9);
    endproperty
    checkConstant_9_Cycle: assert property(constant_9_Cycle);
  Design: "Trust-Hub REM043"
  Origin: "Trust-Hub"
  Reference: "https://trust-hub.org/downloads/resource/data/property-db/REM043.zip"

- ID: 32
  Plain: >-
    `valid` signal should be high only at the final round.
  Threat: ""
  CWE: -1
  CAPEC: -1
  Tool: "JasperGold"
  Assertions: |-
    property validSignal;
      @(posedge clk_i) (sha256_control.data_valid_o==1'b1) |-> (sha256_control.hash_control_st_reg==st_sha_data_valid);
    endproperty
    checkValidSiganlAtValidState: assert property(validSignal);
  Design: "Trust-Hub REM051"
  Origin: "Trust-Hub"
  Reference: "https://trust-hub.org/downloads/resource/data/property-db/REM051.zip"

- ID: 33
  Plain: >-
    The number of cycles between the initial and final round of the encryption operation should always be constant. 
  Threat: ""
  CWE: -1
  CAPEC: -1
  Tool: "JasperGold"
  Assertions: |-
    property constant_80_Cycle;
      @(posedge clk) disable iff (!reset_n) (sha512_core.sha512_ctrl_new == sha512_core.CTRL_IDLE) ##80 (sha512_core.sha512_ctrl_new == sha512_core.CTRL_DONE);
    endproperty
    checkConstant_80_Cycle: assert property(constant_80_Cycle);
  Design: "Trust-Hub REM052"
  Origin: "Trust-Hub"
  Reference: "https://trust-hub.org/downloads/resource/data/property-db/REM052.zip"

- ID: 34
  Plain: >-
    Random number generators should create strong primes so that modulus p and q are not close to each other or should not be easily 
    factorizable. When the primes are generated using random number generators, it should be checked that they are not factorizable. 
    The hamming distance between the modulus should be at least 50%.
  Threat: ""
  CWE: -1
  CAPEC: -1
  Tool: "JasperGold"
  Assertions: |-
    property one;
      @(posedge clk) disable iff (~reset) $countones(RSA.number_q^RSA.number_p) >= 4;
    endproperty
    modulus_p_and_q: assert property (one);
  Design: "Trust-Hub REM061"
  Origin: "Trust-Hub"
  Reference: "https://trust-hub.org/downloads/resource/data/property-db/REM061.zip"

- ID: 35
  Plain: >-
    When the primes are generated using random number generators, it should be checked that the modulus are not generated from first entropy.
  Threat: ""
  CWE: -1
  CAPEC: -1
  Tool: "JasperGold"
  Assertions: |-
    property one;
      @(posedge clk) disable iff (~reset) (reset==1) ##1 (RSA.rand_number != RSA.number_p);
    endproperty
    property two;
      @(posedge clk) disable iff (~reset) (reset==1) ##1 (RSA.rand_number != RSA.number_q);
    endproperty
    first_iteration_p: assert property (one);
    first_iteration_q: assert property (two);
  Design: "Trust-Hub REM071"
  Origin: "Trust-Hub"
  Reference: "https://trust-hub.org/downloads/resource/data/property-db/REM071.zip"

- ID: 36
  Plain: >-
    If private exponent (d) is lower than a threshold t1, the public exponent (e) should not be higher than a threshold t2. 
  Threat: ""
  CWE: -1
  CAPEC: -1
  Tool: "JasperGold"
  Assertions: |-
    property one;
      @(posedge clk) if (!reset && RSA.reg_d <= 10) RSA.reg_e <= 100;
    endproperty
    low_private_exponent: assert property (one);
  Design: "Trust-Hub REM081"
  Origin: "Trust-Hub"
  Reference: "https://trust-hub.org/downloads/resource/data/property-db/REM081.zip"

- ID: 37
  Plain: >-
    If the output of an IP behaves differently or sends different responses under different circumstances in a way 
    that is observable to an unauthorized actor, it can expose security-relevant information about the state of 
    the product, such as whether a particular operation was successful or not. The discrepancy of design behavior 
    should not be observable for different inputs.
  Threat: ""
  CWE: -1
  CAPEC: -1
  Tool: ""
  Assertions: |-
    cover {(ld==1) ##1 (key_r == text_in_r) ## [1:$] done == 1}
    cover {(ld==1) ##1 (key_r != text_in_r) ## [1:$] done == 1}
  Design: "Trust-Hub REM091"
  Origin: "Trust-Hub"
  Reference: "https://trust-hub.org/downloads/resource/data/property-db/REM091.zip"

- ID: 38
  Plain: >-
    All masters and slave IPs integrated on the bus must follow a certain sequence of operations 
    according to the bus protocol to avoid desynchronization between data and permission checking 
    logic.
  Threat: ""
  CWE: -1
  CAPEC: -1
  Tool: "JasperGold"
  Assertions: |-
    // Without the assertion of cycle input (cyc_i) signal, no slave can be selected.
    property p_never_invalid_request;
      @(posedge clk_i) disable iff(rst_i) not(!cyc_i && stb_i);
    endproperty
    // An initial state when no slave or master is ready yet
    sequence s_init_state;
      (!cyc_i && !stb_i);
    endsequence
    // A state when a master is ready, but slave is not selected yet
    sequence s_mst_ready_state;
      (cyc_i && !stb_i);
    endsequence
    // A state when a master and slave are ready
    sequence s_slv_ready_state;
      (cyc_i && stb_i);
    endsequence
    // A state transition from initial state to any other state(master ready, slave ready or initial state)
    property p_init_next_state;
      @(posedge clk_i) disable iff(rst_i) s_init_state |=> (s_init_state or s_mst_ready_state or s_slv_ready_state);
    endproperty
    // A state transition from master ready state to other states (master ready, slave ready or initial state)
    property p_mst_ready_next_state;
      @(posedge clk_i) disable iff(rst_i) s_mst_ready_state |=> (s_init_state or s_mst_ready_state or s_slv_ready_state);
    endproperty
    // A state transition from slave ready state to other states (master ready, slave ready or initial state) when ack_o signal is asserted
    property p_slv_ready_next_state;
      @(posedge clk_i) disable iff(rst_i) (s_slv_ready_state and ack_o) |=> (s_init_state or s_mst_ready_state or s_slv_ready_state);
    endproperty
    // No state transition takes place from slave ready state to other states(master ready or initial state) when ack_o signal is not asserted
    property p_slv_ready_hold_state;
      @(posedge clk_i) disable iff(rst_i) (s_slv_ready_state and !ack_o) |=> s_slv_ready_state;
    endproperty
    // If the current slave is in ready state, input from the master should not change until acknowledge is asserted
    property p_hold_bus (bus);
      @(posedge clk_i) disable iff(rst_i) (s_slv_ready_state) |=> ((bus == $past(bus)) && !ack_o) or ((bus != $past(bus)) && ack_o);
    endproperty
    // SLAVE interfaces MUST be designed so that the [ACK_O], [ERR_O], and [RTY_O] signals are asserted and negated in response to the assertion and negation of [STB_I]
    property p_slv_ready_hold_state1;
      @(posedge clk_i) disable iff(rst_i) (ack_o) and !stb_i |=> !ack_o;
    endproperty
    ASM_never_invalid_request : assert property(p_never_invalid_request);
    ASM_init_next_state : assert property(p_init_next_state);
    ASM_slv_ready_hold_state1 : assert property(p_slv_ready_hold_state1);
    ASM_mst_ready_next_state : assert property(p_mst_ready_next_state);
    ASM_slv_ready_next_state : assert property(p_slv_ready_next_state);
    ASM_slv_ready_hold_state : assert property(p_slv_ready_hold_state);
    ASM_hold_adr : assert property(p_hold_bus(adr_i));
    ASM_hold_dat : assert property(p_hold_bus(dat_i));
    //ASM_hold_sel : assert property(p_hold_bus(sel_i));
    ASM_hold_we : assert property(p_hold_bus(we_i));
  Design: "Trust-Hub RHI011"
  Origin: "Trust-Hub"
  Reference: "https://trust-hub.org/downloads/resource/data/property-db/Version4_jan22.zip"

- ID: 39
  Plain: >-
    There should be no interference between master and slave when the master is communicating   with other slaves.
  Threat: ""
  CWE: -1
  CAPEC: -1
  Tool: "JasperGold"
  Assertions: |-
    // Without the assertion of cycle input (cyc_i) signal, no slave can be selected.
    property p_never_invalid_request;
      @(posedge clk_i) disable iff(rst_i) not(!cyc_i && stb_i);
    endproperty
    // An initial state when no slave or master is ready yet
    sequence s_init_state;
      (!cyc_i && !stb_i);
    endsequence
    // A state when a master is ready but slave is not selected yet
    sequence s_mst_ready_state;
      (cyc_i && !stb_i);
    endsequence
    // A state when a master and slave are ready
    sequence s_slv_ready_state;
      (cyc_i && stb_i);
    endsequence
    // No state transition takes place from slave ready state to other states(master ready or initial state) when ack_o signal is not asserted
    property p_slv_ready_hold_state;
      @(posedge clk_i) disable iff(rst_i) (s_slv_ready_state and !ack_o) |=> s_slv_ready_state;
    endproperty
    //if the current slave is in ready state, input from the master should not change until acknoledge is asserted
    property p_hold_bus (bus);
      @(posedge clk_i) disable iff(rst_i) (s_slv_ready_state) |=> ((bus == $past(bus)) && !ack_o) or ((bus != $past(bus)) && ack_o);
    endproperty
    ASM_never_invalid_request : assert property(p_never_invalid_request);
    ASM_slv_ready_hold_state : assert property(p_slv_ready_hold_state);
    ASM_hold_adr : assert property(p_hold_bus(adr_i));
    ASM_hold_dat : assert property(p_hold_bus(dat_i));
    ASM_hold_we : assert property(p_hold_bus(we_i));
  Design: "Trust-Hub RHI021"
  Origin: "Trust-Hub"
  Reference: "https://trust-hub.org/downloads/resource/data/property-db/Version4_jan22.zip"

- ID: 40
  Plain: >-
    Once the write-once registers are programmed, they should become read only.
  Threat: ""
  CWE: -1
  CAPEC: -1
  Tool: "JasperGold"
  Assertions: |-
    sequence s1;
      ($rose (write) ##[1:$] $rose(register_write_once_example.Write_once_status));
    endsequence
    property write_vulnerability;
      @(posedge Clk) disable iff (!ip_resetn) always (s1);
    endproperty
    ap_write_vulnerability: assert property (write_vulnerability);
  Design: "Trust-Hub RMI041"
  Origin: "Trust-Hub"
  Reference: "https://trust-hub.org/downloads/resource/data/property-db/RMI041.zip"

- ID: 41
  Plain: >-
    Illegal or undocumented instruction can be executed due to weakness in translating specification to implementation. According to RISC-V specification, decoder should ignore rs1 and rd1 field while executing an (imm) instruction.
  Threat: ""
  CWE: -1
  CAPEC: -1
  Tool: "JasperGold"
  Assertions: |-
    property rs1_rd1_field;
      @(posedge clk_i) (~i_ariane.i_cva6.id_stage_i.decoder_i.instr[19:15] || ~i_ariane.i_cva6.id_stage_i.decoder_i.instr[11:7]) |-> i_ariane.i_cva6.id_stage_i.decoder_i.illegal_instr== 1'b0;
    endproperty
  Design: "Trust-Hub RMI051"
  Origin: "Trust-Hub"
  Reference: "https://trust-hub.org/downloads/resource/data/property-db/RMI051.zip"

- ID: 42
  Plain: >-
    Ensure all state registers are initialized during reset. 
  Threat: ""
  CWE: -1
  CAPEC: -1
  Tool: "JasperGold"
  Assertions: |-
    property async_rst_signal1;
      @(posedge clk_i) (!rst_ni |=> (if_stage_i.pc_id_o == 32'h00000000));
    endproperty
    assert property(async_rst_signal1);
  Design: "Trust-Hub RMI061"
  Origin: "Trust-Hub"
  Reference: "https://trust-hub.org/downloads/resource/data/property-db/RMI061.zip"

- ID: 43
  Plain: >-
    The privilege level of the core must be in user specific mode after reset otherwise any other privilege level can pave the way to unauthorized access.
  Threat: ""
  CWE: -1
  CAPEC: -1
  Tool: "JasperGold"
  Assertions: |-
    property async_rst_signal;
      @(posedge clk_i) (!rst_ni |=> (cs_registers_i.priv_lvl_q == 2'b11));
    endproperty
    assert property (async_rst_signal);
  Design: "Trust-Hub RMI062"
  Origin: "Trust-Hub"
  Reference: "https://trust-hub.org/downloads/resource/data/property-db/RMI062.zip"

- ID: 44
  Plain: >-
    Privilege level of the core must be restored to a specific privilege level after processing an interrupt request. 
  Threat: ""
  CWE: -1
  CAPEC: -1
  Tool: "JasperGold"
  Assertions: |-
    property interrupt_handeling;
      @(posedge clk_i) disable iff (!rst_ni) (cs_registers_i.priv_lvl_q == 2'b00 && cs_registers_i.is_irq == 1'b1 && cs_registers_i.csr_irq_sec_i == 1'b1) |=> (cs_registers_i.priv_lvl_n == 2'b00);
    endproperty
    a_interrupt_handeling: cover property(interrupt_handeling);
  Design: "Trust-Hub RMI071"
  Origin: "Trust-Hub"
  Reference: "https://trust-hub.org/downloads/resource/data/property-db/RMI071.zip"

- ID: 45
  Plain: >-
    (REWRITE THIS) It should be checked in design time, whether program counter’s value is writeable from debug access port or not during HALT.
  Threat: ""
  CWE: -1
  CAPEC: -1
  Tool: "JasperGold SPV"
  Assertions: |-
    check_spv -create -from {dbg_uart_rxd} -from_precond {dbg_0.dbg_en_s==1'b1} -to {frontend_0.pc} -name "reciever_to_pc"
  Design: "Trust-Hub RTD011"
  Origin: "Trust-Hub"
  Reference: "https://trust-hub.org/downloads/resource/data/property-db/RTD011.zip"

- ID: 46
  Plain: >-
    Program Counter’s value should not be readable through Debug Access Port (DAP) when a processor is not in HALT mode debugging.
  Threat: ""
  CWE: -1
  CAPEC: -1
  Tool: "JasperGold SPV"
  Assertions: |-
    check_spv -create -from {frontend_0.pc} -from_precond {dbg_0.dbg_en_s==1'b0} -to {dbg_uart_txd} -name "pc_to_trans"
  Design: "Trust-Hub RTD012"
  Origin: "Trust-Hub"
  Reference: "https://trust-hub.org/downloads/resource/data/property-db/RTD012.zip"

- ID: 47
  Plain: >-
    Privileged memory (data memory/physical memory) access should be denied in HALT operation through DAP.
  Threat: ""
  CWE: -1
  CAPEC: -1
  Tool: "JasperGold SPV"
  Assertions: |-
    check_spv -create -from {dbg_uart_rxd} -from_precond {dbg_0.dbg_en_s==1'b1} -to {mem_backbone_0.dmem_din} -name "reciever_to_memory"
    check_spv -create -from {mem_backbone_0.dmem_dout} -from_precond {dbg_0.dbg_en_s==1'b1} -to {dbg_uart_txd} -name "memory_to_transmitter"
  Design: "Trust-Hub RTD013"
  Origin: "Trust-Hub"
  Reference: "https://trust-hub.org/downloads/resource/data/property-db/RTD013.zip"

- ID: 48
  Plain: >-
    During Debugging, control and status registers should be read only. 
  Threat: ""
  CWE: -1
  CAPEC: -1
  Tool: ""
  Assertions: |-
    cover {{debug_req_i && id_stage_i.controller_i.debug_mode_q} ##[1:$] {cs_registers_i.csr_op_i == 2'b01}}
  Design: "Trust-Hub RTD015"
  Origin: "Trust-Hub"
  Reference: "https://trust-hub.org/downloads/resource/data/property-db/RTD015.zip"

- ID: 49
  Plain: >-
    Debugger’s accessibility should be authorized before accepting debug request. 
  Threat: ""
  CWE: -1
  CAPEC: -1
  Tool: "JasperGold SPV"
  Assertions: |-
    check_spv -create -from {pc_id} -to {crash_dump_o.current_pc} -from_precond {debug_req_i== 1'b1} -to_precond {debug_req_i== 1'b1}
  Design: "Trust-Hub RTD061"
  Origin: "Trust-Hub"
  Reference: "https://trust-hub.org/downloads/resource/data/property-db/RTD061.zip"

- ID: 150
  Plain: >-
    Debug should only be initialized in authorized order. 
  Threat: ""
  CWE: -1
  CAPEC: -1
  Tool: "JasperGold"
  Assertions: |-
    a_single_step_dbg_taken_if: assert property (@(posedge clk_i) disable iff (!rst_ni) (id_stage_i.controller_i.ctrl_fsm_cs==BOOT_SET && id_stage_i.controller_i.debug_req_pending == 1'b1 |=> id_stage_i.controller_i.ctrl_fsm_ns==DBG_TAKEN_IF));
    a_single_step_dbg_taken_if1: assert property (@(posedge clk_i) disable iff (!rst_ni) (id_stage_i.controller_i.ctrl_fsm_cs==BOOT_SET && id_stage_i.controller_i.debug_req_pending == 1'b0 |=> id_stage_i.controller_i.ctrl_fsm_ns==FIRST_FETCH));
  Design: "Trust-Hub RTD071"
  Origin: "Trust-Hub"
  Reference: "https://trust-hub.org/downloads/resource/data/property-db/RTD071.zip"

- ID: 151
  Plain: >-
    Debug interface should not have access to the control registers associated with harvesting mechanism of a TRNG. 
  Threat: ""
  CWE: -1
  CAPEC: -1
  Tool: "JasperGold SPV"
  Assertions: |-
    check_spv -create -from {debug_update} -to {mixer_inst.mixer_ctrl_reg} -name "debug_to_harvesting_mixer"
  Design: "Trust-Hub RTG011"
  Origin: "Trust-Hub"
  Reference: "https://trust-hub.org/downloads/resource/data/property-db/RTG011.zip"

- ID: 152
  Plain: >-
    The biasedness of an entropy source of TRNG should be less than a threshold value.
  Threat: ""
  CWE: -1
  CAPEC: -1
  Tool: "JasperGold"
  Assertions: |-
    property biasness;
      @(posedge clk) disable iff (!reset_n) $countones(read_data^$past(read_data,1)) >= 4;
    endproperty
    ap_biasness: assert property (biasness);
  Design: "Trust-Hub RTG021"
  Origin: "Trust-Hub"
  Reference: "https://trust-hub.org/downloads/resource/data/property-db/RTG021.zip"

- ID: 50
  Threat: Insufficient Granularity of Access Control
  Plain: >-
    The product implements access controls via a policy or other feature with the intention to disable or restrict accesses (reads and/or writes) to assets in a system from untrusted agents. However, implemented access controls lack required granularity, which renders the control policy too broad because it allows accesses from unauthorized agents to the security-sensitive assets. 
    Integrated circuits and hardware engines can expose accesses to assets (device configuration, keys, etc.) to trusted firmware or a software module (commonly set by BIOS/bootloader). This access is typically access-controlled. Upon a power reset, the hardware or system usually starts with default values in registers, and the trusted firmware (Boot firmware) configures the necessary access-control protection.
    A common weakness that can exist in such protection schemes is that access controls or policies are not granular enough. This condition allows agents beyond trusted agents to access assets and could lead to a loss of functionality or the ability to set up the device securely. This further results in security risks from leaked, sensitive, key material to modification of device configuration.  
  CWE: 1220
  Language: Not Language-Specific
  Technologies: Not Technology-Specific
  CAPEC: 1-180 
  Attack Pattern Name: Accessing Functionality Not Properly Constrained by ACLs, Exploiting Incorrectly Configured Access Control Security Levels
  Assertions: 
  Design: 
  Origin: "CWE MITRE"
  Reference: "https://cwe.mitre.org/data/definitions/1220.html"
  Observed Examples: CVE-2022-24985, CVE-2021-36934
   
- ID: 52
  Threat: Incorrect Register Defaults or Module Parameters
  Plain: >-
    Hardware description language code incorrectly defines register defaults or hardware Intellectual Property (IP) parameters to insecure values.
    Integrated circuits and hardware IP software programmable controls and settings are commonly stored in register circuits. These register contents have to be initialized at hardware reset to defined default values that are hard coded in the hardware description language (HDL) code of the hardware unit. Hardware descriptive languages also support definition of parameter variables, which can be defined in code during instantiation of the hardware IP module. Such parameters are generally used to configure a specific instance of a hardware IP in the design.
    The system security settings of a hardware design can be affected by incorrectly defined default values or IP parameters. The hardware IP would be in an insecure state at power reset, and this can be exposed or exploited by untrusted software running on the system. Both register defaults and parameters are hardcoded values, which cannot be changed using software or firmware patches but must be changed in hardware silicon. Thus, such security issues are considerably more difficult to address later in the lifecycle. Hardware designs can have a large number of such parameters and register defaults settings, and it is important to have design tool support to check these settings in an automated way and be able to identify which settings are security sensitive.  
  CWE: 1221 
  Language: Verilog (Undetermined Prevalence), VHDL (Undetermined Prevalence)
  Technologies: Not Technology-Specific
  CAPEC: CAPEC-166 
  Attack Pattern Name: Force the System to Reset Values
  Assertions: |-  
  Design: 
  Origin: "CWE MITRE"
  Reference: "https://cwe.mitre.org/data/definitions/1221.html"
  Observed Examples: 
  
- ID: 53
  Threat: Internal Asset Exposed to Unsafe Debug Access Level or State
  Plain: >-
    The product uses physical debug or test interfaces with support for multiple access levels, but it assigns the wrong debug access level to an internal asset, providing unintended access to the asset from untrusted debug agents.
    Debug authorization can have multiple levels of access, defined such that different system internal assets are accessible based on the current authorized debug level. Other than debugger authentication (e.g., using passwords or challenges), the authorization can also be based on the system state or boot stage. For example, full system debug access might only be allowed early in boot after a system reset to ensure that previous session data is not accessible to the authenticated debugger.
    If this protection mechanism does not ensure that internal assets have the correct debug access level during each boot stage or change in system state, an attacker could obtain sensitive information from the internal asset using a debugger.  
  CWE: 1244  
  Language: Not Language-Specific
  Technologies: Not Technology-Specific
  CAPEC: CAPEC-114 
  Attack Pattern Name: Authentication Abuse
  Assertions: |-  
  Design:  
  Origin: "CWE MITRE" 
  Reference: "https://cwe.mitre.org/data/definitions/1244.html"
  Observed Examples: CVE-2019-18827 After ROM code execution, JTAG access is disabled. But before the ROM code is executed, JTAG access is possible, allowing a user full system access. This allows a user to modify the boot flow and successfully bypass the secure-boot process. 
  
- ID: 54
  Threat: Exposure of Sensitive System Information Due to Uncleared Debug Information
  Plain: >-
    The hardware does not fully clear security-sensitive values, such as keys and intermediate values in cryptographic operations, when debug mode is entered.
    Security sensitive values, keys, intermediate steps of cryptographic operations, etc. are stored in temporary registers in the hardware. If these values are not cleared when debug mode is entered they may be accessed by a debugger allowing sensitive information to be accessible by untrusted parties.   
  CWE: 1258 
  Language: Not Language-Specific
  Technologies: Not Technology-Specific
  CAPEC: CAPEC-150, CAPEC-204, CAPEC-37, CAPEC-545 
  Attack Pattern Name: Collect Data from Common Resource Locations, Lifting Sensitive Data Embedded in Cache, Retrieve Embedded Sensitive Data, Pull Data from System Resources
  Assertions: |-  
  Design:  
  Origin: "CWE MITRE" 
  Reference: "https://cwe.mitre.org/data/definitions/1258.html"
  Observed Examples: CVE-2021-33080 Uncleared debug information in memory accelerator for SSD product exposes sensitive system information, CVE-2022-31162 Rust library leaks Oauth client details in application debug logs 
   
- ID: 55
  Threat: Improper Restriction of Security Token Assignment
  Plain: >-
    The System-On-A-Chip (SoC) implements a Security Token mechanism to differentiate what actions are allowed or disallowed when a transaction originates from an entity. However, the Security Tokens are improperly protected.
    Systems-On-A-Chip (Integrated circuits and hardware engines) implement Security Tokens to differentiate and identify which actions originated from which agent. These actions may be one of the directives 'read', 'write', 'program', 'reset', 'fetch', 'compute', etc. Security Tokens are assigned to every agent in the System that is capable of generating an action or receiving an action from another agent. Multiple Security Tokens may be assigned to an agent and may be unique based on the agent's trust level or allowed privileges. Since the Security Tokens are integral for the maintenance of security in an SoC, they need to be protected properly. A common weakness afflicting Security Tokens is improperly restricting the assignment to trusted components. Consequently, an improperly protected Security Token may be able to be programmed by a malicious agent (i.e., the Security Token is mutable) to spoof the action as if it originated from a trusted agent. 
  CWE: 1259   
  Language: Not Language-Specific
  Technologies: Not Technology-Specific
  CAPEC: CAPEC-121, CAPEC-681
  Attack Pattern Name: Exploit Non-Production Interfaces, Exploitation of Improperly Controlled Hardware Security Identifiers
  Assertions: |-  
  Design: 
  Origin: "CWE MITRE"
  Reference: "https://cwe.mitre.org/data/definitions/1259.html"
  Observed Examples:   
- ID: 56
  Threat: Hardware Logic with Insecure De-Synchronization between Control and Data Channels
  Plain: >-
    The hardware logic for error handling and security checks can incorrectly forward data before the security check is complete. Many high-performance on-chip bus protocols and processor data-paths employ separate channels for control and data to increase parallelism and maximize throughput. Bugs in the hardware logic that handle errors and security checks can make it possible for data to be forwarded before the completion of the security checks. If the data can propagate to a location in the hardware observable to an attacker, loss of data confidentiality can occur. 'Meltdown' is a concrete example of how de-synchronization between data and permissions checking logic can violate confidentiality requirements. Data loaded from a page marked as privileged was returned to the cpu regardless of current privilege level for performance reasons. The assumption was that the cpu could later remove all traces of this data during the handling of the illegal memory access exception, but this assumption was proven false as traces of the secret data were not removed from the microarchitectural state.
  CWE: 1264   
  Language: Not Language-Specific
  Technologies: Not Technology-Specific
  CAPEC: CAPEC-233, CAPEC-663
  Attack Pattern Name: Privilege Escalation, Exploitation of Transient Instruction Execution
  Assertions: |-  
  Design: 
  Origin: "CWE MITRE"
  Reference: "https://cwe.mitre.org/data/definitions/1264.html"
  Observed Examples: CVE-2017-5754
